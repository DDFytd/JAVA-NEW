
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>什么是session？什么是cookie？session和cookie有什么区别？</h2>
			<p></p>
            <h3>java小课堂</h3>
            <p>分享人：李浩</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>


        <section>

                    <section>
                        <h3>1.背景介绍</h3>
                    </section>
                    <section>
                    
                        <p>什么是cookie？</p>
                    
                        　<p style="font-size: 30px; text-align: left;">
                            Cookie,中文名称为“小型文本文件”，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
                            由网景公司的前雇员卢·蒙特利在1993年3月发明。最初定义于RFC 2109。目前使用最广泛的 Cookie标准却不是RFC中定义的任何一个，而是在网景公司制定的标准上进行扩展后的产物。
                        </p>
                    </section>
                    
                    <section>
                        <p>什么是session？</p>
                    
                        <p style="font-size: 30px; text-align: left;">
                            在计算机科学领域来说，尤其是在网络领域，会话（session）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议（例如telnet或FTP）中是非常重要的部分。
                            在不包含会话层（例如UDP）或者是无法长时间驻留会话层（例如HTTP）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP
                            cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。
                        </p>
                    
                    </section>
                    
                    <section>
                        <p>什么是token？</p>
                        <p>
                            Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。
                            Token是一个用户自定义的任意字符串。在成功提交了开发者自定义的这个字符串之后，Token的值会保存到服务器后台。只有服务器和客户端前端知道这个字符串，于是Token就成了这两者之间的密钥，它可以让服务器确认请求是来自客户端还是恶意的第三方
                        </p>
                    </section>



        </section>




        <!-- <section> -->

            <section>

                <section>
                    <h3>2.知识剖析</h3>
                </section>
                
                <section>
                    <p>Cookie伊始</p>
                    <p>
                        直接在Cookie中存信息可谓是上古时代的操作了，在服务器还没有那么便宜的情况下，好多网站选择将用户的登录信息存在cookie中，他们把用户名或者用户id转换并签名之后，直接存入Cookie，如果有其他需要的信息，也是如此操作。转换或签名可以是加盐md5，也可以是使用secret的双向加密。用户第二次访问网站的时候，代码中对这段信息进行验证，看看是否是正确的签名的。这样做的好处是：
                        不会再占用服务器资源，直接就在cookie中读取数据，获得结果。坏处是：
                        登录凭据容易被窃取，尤其是那个年代还没有流行https，如果被中间人了，或者以另一种方式拿到了cookie，那就会被窃取登录，另外，每个数据还可能是分开存储的，因此容易被篡改。当然那时的互联网也并没有那么发达，cookie也就存存用户名什么的用于显示。
                
                    </p>
                </section>
                
                <section>
                    <p>Session出现</p>
                    <p style="font-size: 35px;">
                        后来网速变快了，web 应用高速发展，大家意识到了很多问题，cookie 大小不够啊，cookie 每个 key 都这么搞一下暴露太多了等等。从原理上来说，Session 就是
                        Cookie。客户端进入网站后，服务器分配一个
                        Session ID 给客户端种入 Cookie，用户登录时，在服务器查询 Session ID，在服务器写入 Session Object，这个对象里存了用户的登录数据，比如 id 啦，用户名啦，登录状态 / 角色等等。
                        另外分配 Session ID 也可以是懒分配，也就是等到在服务器存 Session Object 的时候再分配也没有关系，Session ID 的分配可以是用 UserID
                        来进行加密分配，也可以用毫不相关的时间等信息进行加密分配，只需要保证这个
                        sid 唯一，不容易被伪造即可。Session 的存放也是可重可轻，如果觉得 Session 很重要，那么可以放入 mysql，如果觉得 Session 不怎么重要，甚至可以放入内存，重启丢失。
                
                
                    </p>
                </section>
                
                
                <section>
                    <p style="font-size: 35px;">
                        Session 到至今还是非常非常多的网站在用，原因就是在于其实除了 https 以外的问题，并没有什么问题，IE >= 10 之后，Cookie 也可以跨域，那么 Session 就没有什么问题。
                        好处是： 在客户端除了 sid 以外，看不到任何信息，当然不太容易篡改。
                        坏处是： 取 Session 的时候，是会需要再 query 一次的，也容易被窃取，当然这并不是 Session / Cookie 的锅，http下，啥都是一清二楚的。
                        另外，优缺点都是相对于时代和业务来说的，存 Cookie 的时代服务器的性能不高，也没有 memcache 或者 redis 这种东西，存入 mysql 就需要再 query 一次，负载均衡当然不能同步 内存中的
                        Session，Cookie 成为了首选，那么现在呢，这点算力恐怕算不了什么，那么 Session 的那个坏处，就应该被划掉，Session 理所当然成为了流行的会话管理方式。Session 和 Cookie
                        都不需要前端介入，服务端通过
                        Set-Cookie http 头就可以完成 sid 和 Cookie 的更新。
                
                    </p>
                </section>
                
                <section>
                    <p>使用token</p>
                
                    <p style="font-size: 27px;">
                        上边两种方法代表了两种存登录凭据的思想，一种是把凭据存客户端，一种是把凭据存服务端。那么随着前后端分离的运动，上边两种的登录凭据的思想也发展出了两种不使用 Cookie 的方法：把凭据存服务端的
                        Session，把他的Token，单拿出来，在JSON中传递，或者在 http 头里传递或者其他方式传递。
                    </p>
                    <p style="font-size: 27px;">
                        JWT（JSON Web Token） 代表了把凭据存客户端的思想，和当时的 Cookie 有点像，登录的时候把那些需要的信息
                        base64 编码作为一段，然后再对这些字段用 secret 进行签名，连起来这么一段 Token 去发给客户端作为凭据。凭据存在客户端的好处是： 登录状态都是跟着客户端跑的，时效信息都存在客户端，Session
                        如果过期了，要对
                        Session 数据库进行垃圾清理，那么凭据存在客户端就不需要，丢了就是登出。因为都是跟着客户端跑的，在服务器扩大搞集群，搞异地多活，就不需要考虑读数据库这种事情，因为都是客户端请求为 based ，随便哪个服务器来
                        handle
                        请求都没有问题。凭据存客户端坏处是： 当凭据内容越来越多，Token 也会越来越长，每一次请求都会携带这么大这么长的内容，显然不是非常合适。JWT 还有个问题就是中间那部分是 base64
                        编码的，如果熟悉标准的话，等于就是明文存储凭据了，虽然不能改，当然还是能看到。Token 类的鉴权需要前端参与并存储，存储一般会放在 localStorage 等地方，因此其实是比较容易受到 XSS 的影响。Cookie
                        类的鉴权容易受到
                        CSRF 的影响。
                
                    </p>
                </section>
                
                <section>
                    <p>基于 Token 的身份验证方法</p>
                
                    <p>
                        <p>
                            使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：
                
                            客户端使用用户名跟密码请求登录
                            服务端收到请求，去验证用户名与密码
                            验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
                            客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
                            客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
                            服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据
                
                
                </section>
                
                <section>
                    </p>
                    <img src="img-java/cookie/20170421192200929.jpg" alt="">
                    </p>
                </section>

            </section>
               
                



               
        <section>
        <section>
            <h3>3.常见问题 & 解决方案</h3>
     
        </section>

            <section>
                <p>通俗讲Cookie</p>
                <p style="text-align: left">
                答：Cookie是服务器给客户端发的一个「通信证」。无论谁访问服务器时都必须携带自己的「通行证」，这样服务器就可以通过「通行证」确定用户身份了。注：Cookie有不可跨域名性。即浏览器不会将http://baidu.com的cookie发送给http://google.com
                </p>
            </section>
            <section style="text-align: left;">
                <p>Cookie有属性吗？都是什么？</p>
                <p style="text-align: left; font-size: 30px;">
                    <p>答：Cookie有属性，它们是：</p>
                    <p>1. String「name」 ：该Cookie的「名称」。Cookie一旦创建，名称便不可更改。</p>
                    <p>2. Object「value」：该Cookie的「值」</p>
                    <p>3.Int「maxAge」：该Cookie的「失效时间」，单位秒注：如果为正数，则该Cookie在maxAge秒后失效。如果为负数，则该Cookie为临时Cookie，关闭浏览器即失效。如果为0，表示删除该Cookie。默认为-1，即关闭浏览器即失效</p>
                    <p>4.Boolean「secure」：「是否仅使用安全协议传输」，默认为false</p>
                </p>
            </section>

            <section style="text-align: left;">
                <p>5.String「path」：该Cookie的「使用路径」注：如果设置为“/shit/”，则只有“http:http://xxx.xxx.xxx/shit”的程序可以访问该Cookie。如果设置为“/”，则本域名下的程序都可以访问Cookie，注意最后一个字符必须为“/”。</p>
                <p>6.String「domain」：「可以访问该Cookie的域名」。注：如果设置为".http://google.com"，则所有以"http://google.com"结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。</p>
                <p>7.String「comment」：该Cookie的「用处说明」，用来再浏览器显示Cookie信息的时候显示该说明。</p>
                <p>8.Int「version」：该Cookie的「版本号」。0表示遵循Netspace的Cookie规范，1表示遵循W3C的RFC2109规范。</p>
            </section>

            <section style="text-align: left;">
                <p>怎么修改Cookie？怎么删除Cookie？</p>
                <p style="text-align: left; font-size: 30px;">
                    <p>答：
                    
                    修改：创建同名Cookie，覆盖原来的Cookie
                    </p>
                    <p>
                    删除：创建同名Cookie，并将maxAge属性设置为0
                    </p>
                </p>
            </section>

            <section style="text-align: left;">
                <p>Cookie有什么用</p>
                <p style="text-align: left; font-size: 30px;">
                    <p>答：挺多的，列举几个。自动登陆：第一次登陆成功后，给你的电脑发送一个存有你用户名的Cookie。
                        于是，在Cookie失效之前，你每一次登陆服务器，服务器都会直接读取你的Cookie中的用户名，然后返回给你一个登陆成功的页面。
                        挺危险的是吧，所以通常会有一些加密手段以及借助Session的帮助。京东未登录时的购物车：意思差不多，诸位应该明白。
                    </p>
                </p>
            </section>

                                    <section>
                                        <p>通俗说Session</p>
                                        <p style="text-align: left">答：Session是「你去理发店办卡后，店家记录你剩余次数的那个大本子」。它保存在服务器端，不负责记录你还能剪几次，但是它会把客户端的某种信息保存在服务器上。当客户端下一次来访问时，根据信息确定客户身份即可。
                                        </p>
                                    </section>
                                    
                                    <section>
                                        <p>Session保存在哪</p>
                                        <p style="text-align: left">
                                            答：Session保存在服务器端的内存中。
                                        </p>
                                    </section>
                                    
                                    <section>
                                        <p>Session的有效期</p>
                                        <p style="text-align: left">
                                            答：由「最后访问时刻」和「超时时段」构成。当「当前时刻」 - 「超时时段」>「最后访问时刻」时，Session就失效了。
                                    
                                            在Tomcat中的「超时时段」为20分钟。
                                        </p>
                                    </section>

    </section>

    <!-- <section>


    </section>
         -->
        <section>
            <h3>4.解决方案</h3>
            <h4>见前一章节</h4>
        </section>
        
        <section>
            <h3>5.编码实战</h3>
	
        </section>


        <section>
        <section>
            <h3>6.扩展思考</h3>
        </section>
        <section>
            <p style="text-align: center">
                面试经典问题：Cookie禁用了，Session还能用吗？
            </p>
        </section>
        <section>
            <p style="text-align: left">
                解答：
                <a href="https://segmentfault.com/q/1010000007715137" target="_blank">"https://segmentfault.com/q/1010000007715137"</a>
        
        
            </p>
            <p>
        
            </p>
            <p style="text-align: left">
            </p>
        </section>
        <section>
            <p>基于cookie的身份验证方式和基于token的身份验证方式</p>
            <a href="https://www.jianshu.com/p/ce9802589143" target="_blank">https://www.jianshu.com/p/ce9802589143</a>
            <p></p>
        </section>

        </section>
        


        <section>
        <section>
            <h3>7.参考文献</h3>
        </section>
        <section style="text-align: center">
            <p>参考文档：</p>
            <p>
                <a href="https://www.zhihu.com/topic/19616699/top-answers" target="_blank">https://www.zhihu.com/topic/19616699/top-answers</a>
                <a href="https://my.oschina.net/xianggao/blog/395675" target="_blank">https://my.oschina.net/xianggao/blog/395675</a>
                <a href="http://www.10tiao.com/html/169/201803/2650825233/1.html" target="_blank">http://www.10tiao.com/html/169/201803/2650825233/1.html</a>
            </p>
        </section>

        </section>
        
        


        <section>
            <h3>8.更多讨论</h3>
        </section>

        <section>
            <h4>鸣谢</h4>
            <p>感谢观看,如有出错,恳请指正</p>
            <p><small>BY : 李浩</small></p>
        </section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>