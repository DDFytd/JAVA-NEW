
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>什么是RMI，什么是RPC，两者之间的区别是什么？</h2>
            <p></p>
            <h3>java小课堂</h3>
            <p>分享人：岳晓鹏</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.编码实战</p>
            <p>4.常见问题</p>
            <p>5.参考文献</p>
            <p>6.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>

            <h3>RMI</h3>
            <p>Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，
                一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。
                远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。

                Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。
                客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。
                这样一来，程序员只需关心如何通过自己的接口句柄发送消息。

        </section>
        <section>

            <h3>RPC</h3>
            <p>
                RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。
                它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。
                即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。

        </section>

        <section>
            <h3>2.知识剖析</h3>
        </section>
		
				

		
		<section>

            <h3>RPC 与其它远程调用方式比较</h3>
            <p>
            RPC 与 HTTP、RMI、Web Service 都能完成远程调用，但是实现方式和侧重点各有不同。
        </section>
            <section>
                <h3>HTTP</h3>
                <p>
                HTTP（HyperText Transfer Protocol）是应用层通信协议，使用标准语义访问指定资源（图片、接口等），
                网络中的中转服务器能识别协议内容。HTTP 协议是一种资源访问协议，通过 HTTP 协议可以完成远程请求并返回请求结果。

                HTTP 的优点是简单、易用、可理解性强且语言无关 ，在远程服务调用中包括微博有着广泛应用。HTTP 的缺点是协议头较重，
                一般请求到具体服务器的链路较长，可能会有 DNS 解析、Nginx 代理等。

                RPC 是一种协议规范，可以把 HTTP 看作是一种 RPC 的实现，也可以把 HTTP 作为 RPC 的传输协议来应用。
                RPC 服务的自动化程度比较高，能够实现强大的服务治理功能，和语言结合更友好，性能也十分优秀。与 HTTP 相比，
                    RPC 的缺点就是相对复杂，学习成本稍高。

            </section>
        <section>
            <h3>RMI</h3>
            <p>RMI（Remote Method Invocation）是指 Java 语言中的远程方法调用，RMI 中的每个方法都具有方法签名，
            RMI 客户端和服务器端通过方法签名进行远程方法调用。RMI 只能在 Java 语言中使用， 可以把 RMI 看作面向对象的 Java RPC 。
        </section>



		<section>

            <h3>Web Service</h3>
            <p>
                Web Service 是一种基于 Web 进行服务发布、查询、调用的架构方式，重点在于服务的管理与使用。Web Service 一般通过 WSDL 描述服务，使用 SOAP（简单对象访问协议）通过 HTTP 调用服务。
                RPC 是一种远程访问协议，而 Web Service 是一种体系结构，Web Service 也可以通过 RPC 来进行服务调用，因此 Web Service 更适合同一个 RPC 框架进行比较。当 RPC 框架提供了服务的发现与管理，并使用 HTTP 作为传输协议时，其实就是 Web Service。
                相对 Web Service，RPC 框架可以对服务进行更细粒度的治理，包括流量控制、SLA 管理等，在微服务化、分布式计算方面有更大的优势。

        </section>


       <section>
        <h3>RPC与RMI的区别</h3>

           <p>（1）RPC 跨语言，而 RMI只支持Java。
        </section>
        <section>
            <p>（2）RMI 调用远程对象方法，允许方法返回 Java 对象以及基本数据类型，而RPC 不支持对象的概念，
                传送到 RPC 服务的消息由外部数据表示 (External Data Representation, XDR) 语言表示，
                这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递，
                可以说 RMI 是面向对象方式的 Java RPC 。
        </section>
        <section>

            <p>（3）在方法调用上，RMI中，远程接口使每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新方法就不能被RMI客户方所调用。
        </section>
        <section>

            <p>在RPC中，当一个请求到达RPC服务器时，这个请求就包含了一个参数集和一个文本值，通常形成“classname.methodname”的形式。这就向RPC服务器表明，被请求的方法在为 “classname”的类中，名叫“methodname”。然后RPC服务器就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与RPC请求中的类型是匹配的。一旦匹配成功，这个方法就被调用了，其结果被编码后返回客户方。
        </section>
        <section>

            <h3>RMI远程调用步骤：</h3>
            <p>
                1，客户调用客户端辅助对象stub上的方法
            <p>   2，客户端辅助对象stub打包调用信息（变量，方法名），通过网络发送给服务端辅助对象skeleton
            <p>   3，服务端辅助对象skeleton将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象
            <p>   4，调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象skeleton
            <p>   5，服务端辅助对象将结果打包，发送给客户端辅助对象stub
            <p>    6，客户端辅助对象将返回值解包，返回给调用者
            <p>    7，客户获得返回值
        </section>

		<section>
		
            <h3>3.编码实战</h3>
            <p>简单的进行一个RMI的简单调用</p>
        </section>



        <section>

            <h3>数据的传递问题</h3>

            <p>
                在Java程序中引用类型的参数传递是按引用传递的，对于在同一个虚拟机中的传递时是没有问题的，因为的参数的引用对应的是同一个内存空间，但是对于分布式系统中，由于对象不再存在于同一个内存空间，虚拟机A的对象引用对于虚拟机B没有任何意义
                可以将对象序列化为字节流，实现java.io.Serializable接口


        </section>


        <section>
		
            <h3>5.参考资料</h3>
            <p>https://blog.csdn.net/shan9liang/article/details/8995023
            <p>https://www.jianshu.com/p/c34ee94fa3d2
            <p>https://www.jianshu.com/p/9b22b9dfba30
        </section>

        <section>
            <h3>6.更多讨论</h3>
            <p></p>
        </section>

        <section>
		
            <h3>鸣谢</h3>
            <p>感谢观看,如有出错,恳请指正</p>
           
        </section>

    </div>
    <script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
